**********
2021/08/01
**********
어플의 한 화면에 대한 api에서
해당 화면에서 클릭해야지 연결되는 정보들은 해당 api에 담지 않는건가?'

1.
골라먹는 맛집의 경우 조건을 설정하여서 식당 리스트들을 불러온다. 
인기 프랜차이즈는 리뷰가 좋고 카테고리가 프랜차이즈인 식당 리스트들을 불러온다.
새로 들어왔어요는 최근에 등록한 식당 리스트들을 불러온다.
<담기는 기능>
위치정보
검색
이벤트
음식 카테고리로 식당 조회
인기 프랜차이즈
새로 들어왔어요
골라먹는 맛집

이 모든 것을 홈화면 api하나로 담아야 하는 것인지?
'음식 카테고리로 식당 조회' 기능은 홈화면에서 바로 보이는 것이 아니라
음식 카테고리 아이콘을 클릭하면 해당 기능으로 넘어가는 식이다.

2.
My이츠에서 당장 보이는 정보들은 이름, 전화번호 뿐이고
나머지는 탭을 누르고 들어가야됨 
Ex) 즐겨찾기, 배달 주소 관리

그럼 My이츠 화면 api에 즐겨찾기나 배달 주소 관리 정보를 넣는 것이 아니라 
즐겨찾기 api, 배달 주소 관리 api를 따로 작성한 뒤 프론트에서 이를 연결하는 건가?


**********
2021/08/02
**********
특정 식당에 들어가면 세부메뉴에 따라서 메뉴들이 정렬되어서 나타난다
예를 들어 버커킹의 경우 스페셜오퍼, X세트, 와퍼 세트, 와퍼주니어 세트, 비프$치킨 세트, .....,사이드, 드링크
만약 프랜차이즈의 메뉴구성이 완전히 똑같다면 매장마다 메뉴에 대한 데이터를 넣지 않고 프랜차이즈 메뉴 테이블을 따로 만들어서 가져오면 되지만
세부메뉴가 같은 프랜차이즈임에도 매장마다 다른 경우가 있고 판매하는 메뉴도 다른 경우가 있다
개인 식당의 경우는 사장님이 임의로 정하는 것이므로 매장마다 다를 것이다.
1. 따라서 그냥 각 매장마다 판매하는 데이터를 전부 넣어야 함

2. 문제는 식당 조회 API의 Dao파일에서 쿼리를 통해 세부메뉴에 따라서 메뉴들을 정렬시켜야 하는데 식당마다 입력한 세부메뉴가 전부 다르기 때문에
어떤식으로 필터링을 해야할 지 모르겠다. 어쩌면 데이터를 전달 할 때 굳이 정렬해서 보낼 필요가 없을 수 있겠다는 생각이 들었다.
나는 json에 세부메뉴 데이터를 담아서 클라이언트에 보내주면 클라이언트가 세부메뉴 데이터를 가지고 정렬해서 화면에 나타내는 방식이 가능할까?
팀원이랑 논의 필요

**********
2021/08/03
**********
orderby

쿠폰 소멸시간은 컬럼추가 대신에 쿠폰 조회나 쿠폰 사용 api에서 거르는 방식으로 구현

경도, 위도를 서버에서 입력  지도 api  or
geo= 주소입력->경도 위도로 변환.  클라이언트와 상의

홈화면 api와 골라먹는 맛집 api따로 골라먹는 맛집 api에는 쿼리스트링 적용해서
대신 홈화면 api에도 골라먹는 맛집에 대한 result를 담아야 함

쿠팡앱으로 로그인 -> 네이버 로그인 or 카카오톡 로그인으로 대체

**********
2021/08/04
**********
쿼리에서, 여러 개의 조건문이 있을 때
ex) 치타배달 = ? (Y or N) , 최소주문 =< ? , 배달비 =< ?
여기서 사용자가 최소주문 15000원 이하, 배달비 5000원 이하를 입력,  치타배달은 조건 입력 x
그러면 치타배달 유무에 상관없이 사용자가 입력한 조건에 맞춰서 필터링 진행
위 3개의 조건을 모두 입력하지 않으면 그냥 전체 데이터를 조회

값을 무조건 받아야 됨, 사용자의 클릭에 따라 받아오는 파라미터를 바꿔서 조건문 로직 수행
쿼리스트링 - Cheetah = Y -> 필터링 후 조회, T -> 전체 조회
최소주문 - 0원 , 5000원 단위, 전체
배달비 - 0원, 1000원 단위, 전체

사용자가 전달한 파라미터를 받아와서 쿼리에서 사용

**********
2021/08/05
**********
쿼리스트링 여러개가 상당히 까다롭다

프랜차이즈api 최소주문금액은 일단 제외해야됨

**********
2021/08/06
**********
쿠팡이츠에서 조건을 설정하여 식당을 필터링하는 기능 구현 성공
Dao의 쿼리를 여러개 만들고 provider에서 쿼리스트링에 따라서 각각의 Dao를 지정해 주었다.
처음에는 Controller에서도 다중 조건문으로 걸렀으나 이렇게 되면 쿼리스트링의 파라미터가 제대로 전달이 안 되었다.
예를 들어 deliveryFee는 값을 전달하지 않고 minimunAmoint에만 값을 전달하고 싶어도 사용자가 minimunAmount에 전달한 값이 deliveryFee에
전달되기 때문에 provider에서는 deliveryFee가 들어온 줄 알고 해당 Dao로 연결한다.
컨트롤러에서 이 부분을 지우니 해결되었다.

**********
2021/08/07
**********
카트에 담기
각 메뉴에서 메뉴의 수량과 각 메뉴에 대한 추가메뉴를 선택하여 담음
1. AdditonalMenuPerCart 2. MenuPerCart에 데이터를 삽입
3. Cart에 userId, restId, userAddressId 삽입하여 해당 cart에 대한 row 생성, 빈 컬럼은 다른 카트 api에서 입력

(정리)3가지 테이블에 데이터를 insert
1. Cart에 userId, restId, userAddressId 삽입하여 해당 cart에 대한 row 생성
나머지 컬럼은 14,15 API으로 삽입
 userAddressId는 Body에 담지 않지만, 서브쿼리를 이용하여 userId에 연결된 대표 주소인덱스를 받아서 Cart의 userAddressId에 삽입한다.
2.  MenuPerCart에 cartId, menuId, menuCount 삽입하여 해당 카트에 어떤 메뉴를 몇개 담을 지 정한다.
3. AdditonalMenuPerCart에 cartId, menuId, additionalMenuId, addtionalMenuCount 삽입하여
각 메뉴마다 어떤 추가 메뉴를 몇개 담을 지 정한다.


카트 보기 : 선택한 주소정보(주소 카테고리, 대략주소+상세주소), 식당 이름, 치타배달여부, 카트에 담은 메뉴들과 가격, 배달비, 주문금액, 결제수단

주소는 userAddress에 담은 읍면동 행정코드를 타고 행정구역 테이블 3가지를 연결 후
CONCAT(sidoName,' ',sigunguName,' ',eupMyeonDongName,' ',detailAddress) as address

**********
2021/08/08
**********

카트 보기에서 메뉴 당 총 가격 = 메뉴 가격 * 메뉴 개수 + (추가메뉴 1번 가격+ 추가메뉴 2번 가격 + ....)

카트의 담긴 메뉴마다 추가 메뉴가 여러 개가 담길 수 있기 때문에 메뉴와 추가메뉴의 정보를 함께 불러오면 row가 중복된다.
CONCAT((menuPrice*MPC.menuCount + AM.additionalMenuPrice), '원') 이런식으로 컬럼을 잡으면
추가 메뉴가 1개인 경우는 문제가 없지만, 추가 메뉴 3개가 붙은 메뉴의 경우 row가 3개가 됨.
inner join을 바꾸는 법을 생각해봤지만 쉽지 않았고, 추가 메뉴에 대한 값은 menuId로 그룹핑하고 sum함수를 사용하여 서브쿼리로 정리하고 하나로 묶은 다음 본 메뉴의 정보와 더함.
이렇게 하면 카트 당 어떤 메뉴가 몇개 담겼는지, 또 각 메뉴당 추가메뉴는 어떤 것들이 담겼는지와 메뉴 당 총가격을 계산 가능
해결
+) 한 메뉴에 추가메뉴가 여러 개인 경우 추가메뉴의 내용도 같이 나타나야됨. 이 역시도 row가 중복됨
-> 'group_CONCAT'으로 해결

카트담기에서 결제수단 넣어줘야됨 - 수정

카트에서 주소변경 -> 앱을 실제로 만져보니 카트에서 주소변경이 곧 유저의 대표 주소를 바꾸는 것이다. 카트에서 주소를 바꿔면 홈화면에서도 유저의 대표주소가 바뀐다.
20번: 배달지 대표 지역 설정 api와 통합

카트 메뉴추가 -> 식당 메뉴창으로 연결. 카트 내 메뉴추가 api는 따로 필요하지 않을 듯

**********
2021/08/09
**********

카트 담기 API 나눠야 함
카트 인덱스를 생성
카트 추가

홈화면 api 다시 통합
result 에 배열명 부여


**********
2021/08/10
**********
카트 생성과 카트 담기로 나눔

홈화면 다시 합치기

api 전체 검토하여 result 객체 안 배열들 마다 구분을 위해서 배열명을 부여

user정보를 담아서 사용하는 경우 jwt 추가

결제하기 API 수정

카트 생성 -> 카트 담기 -> 결제하기
